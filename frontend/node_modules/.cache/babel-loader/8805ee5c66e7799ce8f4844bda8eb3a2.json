{"ast":null,"code":"/**\n * @hidden\n *\n * Render the svg <path> element.\n *\n * @param points (array) Represents the points coordinates as an array of tuples.\n * @param command (function) The command that is used (bezierCommand, lineCommand).\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) a svg path command.\n * @output (string) a Svg <path> element\n */\nexport var svgPath = function (points, command) {\n  if (points.length === 0) {\n    return '';\n  } // build the d attributes by looping over the points\n\n\n  var d = points.reduce(function (acc, point, i, a) {\n    return i === 0 ? // if first point\n    \"M \" + point[0] + \",\" + point[1] : // else\n    acc + \" \" + command(point, i, a);\n  }, '');\n  return \"<path d=\\\"\" + d + \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\"/>\";\n};\n/**\n * @hidden\n *\n * Returns the properties of a line.\n *\n * @param pointA (array) [x,y] Represents the start point coordinates.\n * @param pointB (array) [x,y] Represents the end point coordinates.\n * @output (object) { length: (integer), angle: (integer) }\n */\n\nexport var line = function (pointA, pointB) {\n  var lengthX = pointB[0] - pointA[0];\n  var lengthY = pointB[1] - pointA[1];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n/**\n * @hidden\n *\n * Create a function to calculate the position of the control point.\n *\n * @param lineCalc (function) Represents the line function.\n *      @param pointA (array) [x,y] Represents the start point coordinates.\n *      @param pointB (array) [x,y] Represents the end point coordinates.\n *      @output (object) { length: (integer), angle: (integer) }\n * @output (function) closure.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n */\n\nexport var controlPoint = function (lineCalc) {\n  return function (current, previous, next, reverse) {\n    // when 'current' is the first or last point of the array\n    // 'previous' and 'next' are undefined \n    // replace with 'current'\n    var p = previous || current;\n    var n = next || current;\n    var smooth = 0.1; // properties of the line between previous and next \n\n    var l = lineCalc(p, n); // If is end-control-point, add PI to the angle to go backward\n\n    var angle = l.angle + (reverse ? Math.PI : 0);\n    var length = l.length * smooth; // The control point position is relative to the current point\n\n    var x = current[0] + Math.cos(angle) * length;\n    var y = current[1] + Math.sin(angle) * length;\n    return [x, y];\n  };\n};\n/**\n * @hidden\n *\n * Create a function to calculate a bezier curve command.\n *\n * @param controlPointCalc (function) Represents the controlPoint function.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n * @output (function) closure.\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) 'C x2,y2 x1,y1 x,y' Cubic bezier command.\n */\n\nexport var bezierCommand = function (controlPointCalc) {\n  return function (point, i, a) {\n    // start control point\n    var _a = controlPointCalc(a[i - 1], a[i - 2], point),\n        cpsX = _a[0],\n        cpsY = _a[1]; // end control point\n\n\n    var _b = controlPointCalc(point, a[i - 1], a[i + 1], true),\n        cpeX = _b[0],\n        cpeY = _b[1];\n\n    return \"C \" + cpsX + \",\" + cpsY + \" \" + cpeX + \",\" + cpeY + \" \" + point[0] + \",\" + point[1];\n  };\n};","map":{"version":3,"sources":["C:/Users/Admin/LeadManagement/frontend/node_modules/@progress/kendo-react-inputs/dist/es/colors/utils/svg-calc.js"],"names":["svgPath","points","command","length","d","reduce","acc","point","i","a","line","pointA","pointB","lengthX","lengthY","Math","sqrt","pow","angle","atan2","controlPoint","lineCalc","current","previous","next","reverse","p","n","smooth","l","PI","x","cos","y","sin","bezierCommand","controlPointCalc","_a","cpsX","cpsY","_b","cpeX","cpeY"],"mappings":"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","sourcesContent":["/**\n * @hidden\n *\n * Render the svg <path> element.\n *\n * @param points (array) Represents the points coordinates as an array of tuples.\n * @param command (function) The command that is used (bezierCommand, lineCommand).\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) a svg path command.\n * @output (string) a Svg <path> element\n */\nexport var svgPath = function (points, command) {\n    if (points.length === 0) {\n        return '';\n    }\n    // build the d attributes by looping over the points\n    var d = points.reduce(function (acc, point, i, a) {\n        return i === 0 ?\n            // if first point\n            \"M \" + point[0] + \",\" + point[1] :\n            // else\n            acc + \" \" + command(point, i, a);\n    }, '');\n    return \"<path d=\\\"\" + d + \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\"/>\";\n};\n/**\n * @hidden\n *\n * Returns the properties of a line.\n *\n * @param pointA (array) [x,y] Represents the start point coordinates.\n * @param pointB (array) [x,y] Represents the end point coordinates.\n * @output (object) { length: (integer), angle: (integer) }\n */\nexport var line = function (pointA, pointB) {\n    var lengthX = pointB[0] - pointA[0];\n    var lengthY = pointB[1] - pointA[1];\n    return {\n        length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n        angle: Math.atan2(lengthY, lengthX)\n    };\n};\n/**\n * @hidden\n *\n * Create a function to calculate the position of the control point.\n *\n * @param lineCalc (function) Represents the line function.\n *      @param pointA (array) [x,y] Represents the start point coordinates.\n *      @param pointB (array) [x,y] Represents the end point coordinates.\n *      @output (object) { length: (integer), angle: (integer) }\n * @output (function) closure.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n */\nexport var controlPoint = function (lineCalc) {\n    return function (current, previous, next, reverse) {\n        // when 'current' is the first or last point of the array\n        // 'previous' and 'next' are undefined \n        // replace with 'current'\n        var p = previous || current;\n        var n = next || current;\n        var smooth = 0.1;\n        // properties of the line between previous and next \n        var l = lineCalc(p, n);\n        // If is end-control-point, add PI to the angle to go backward\n        var angle = l.angle + (reverse ? Math.PI : 0);\n        var length = l.length * smooth;\n        // The control point position is relative to the current point\n        var x = current[0] + Math.cos(angle) * length;\n        var y = current[1] + Math.sin(angle) * length;\n        return [x, y];\n    };\n};\n/**\n * @hidden\n *\n * Create a function to calculate a bezier curve command.\n *\n * @param controlPointCalc (function) Represents the controlPoint function.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n * @output (function) closure.\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) 'C x2,y2 x1,y1 x,y' Cubic bezier command.\n */\nexport var bezierCommand = function (controlPointCalc) { return function (point, i, a) {\n    // start control point\n    var _a = controlPointCalc(a[i - 1], a[i - 2], point), cpsX = _a[0], cpsY = _a[1];\n    // end control point\n    var _b = controlPointCalc(point, a[i - 1], a[i + 1], true), cpeX = _b[0], cpeY = _b[1];\n    return \"C \" + cpsX + \",\" + cpsY + \" \" + cpeX + \",\" + cpeY + \" \" + point[0] + \",\" + point[1];\n}; };\n"]},"metadata":{},"sourceType":"module"}